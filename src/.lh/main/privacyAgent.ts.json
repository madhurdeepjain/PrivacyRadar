{
  "sourceFile": "main/privacyAgent.ts",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 1,
      "patches": [
        {
          "date": 1765304649807,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        },
        {
          "date": 1765304854755,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,9 @@\n     if (entries.length > 0) {\n       // Sort by value descending (e.g. flows) and take top 3\n       const topCountries = entries\n         .sort((a, b) => (b[1] as number) - (a[1] as number))\n-        .slice(0, 3)\n+        .slice(0, 5)\n         .map(([country, value]) => `${country} (${(value as number).toLocaleString()} flows)`)\n       destinationsText = `Most traffic appears to be going to: ${topCountries.join(', ')}.`\n     }\n   }\n"
        }
      ],
      "date": 1765304649807,
      "name": "Commit-0",
      "content": "import { GoogleGenerativeAI } from '@google/generative-ai'\n\nexport type TopApp = {\n  name: string\n  totalBytes: number\n}\n\nexport type PrivacySnapshot = {\n  totalPackets: number\n  totalApps: number\n  topApps: TopApp[]\n  // Optional: aggregate bytes across all apps\n  totalBytes?: number\n  // Optional: when the user wants a deep dive on a specific app\n  focusAppName?: string\n  focusAppBytes?: number\n  // Optional: some callers send a full focusApp object instead of name/bytes\n  focusApp?: {\n    name?: string\n    totalBytes?: number\n    pid?: number | null\n  } | null\n  // Optional: high-level geolocation / destination information for this capture\n  geoSummary?: string | null\n  // Optional: bytes per country/region (e.g. { US: 12345, DE: 6789 })\n  geoByCountry?: Record<string, number> | null\n  // Optional: derived geolocation summary object from renderer (e.g. topCountries/totalFlows)\n  geo?: {\n    topCountries?: { country: string; count: number }[]\n    totalFlows?: number\n  } | null\n}\n\n// Local summary – used when Gemini is unavailable or fails\n\nfunction buildLocalSummary(snapshot: PrivacySnapshot): string {\n  const { totalApps, totalPackets, topApps } = snapshot\n\n  const focusName = snapshot.focusAppName ?? snapshot.focusApp?.name\n  const focusBytes = snapshot.focusAppBytes ?? snapshot.focusApp?.totalBytes\n\n  const primaryApp = focusName\n    ? `${focusName} (${(focusBytes ?? 0).toLocaleString()} bytes)`\n    : topApps[0]\n      ? `${topApps[0].name || 'Unknown'} (${topApps[0].totalBytes.toLocaleString()} bytes)`\n      : 'no dominant application yet'\n\n  const summary = `Monitoring ${totalApps} app${\n    totalApps === 1 ? '' : 's'\n  } with ${totalPackets.toLocaleString()} packet${\n    totalPackets === 1 ? '' : 's'\n  } observed so far. The highest-volume traffic currently appears to be from ${primaryApp}.`\n\n  const keyInsightsParts: string[] = []\n  keyInsightsParts.push(\n    `Most of the observed traffic volume is currently associated with ${primaryApp}.`\n  )\n  if (totalApps > 0) {\n    keyInsightsParts.push(\n      `Network activity is spread across ${totalApps} app${totalApps === 1 ? '' : 's'}.`\n    )\n  }\n  if (typeof totalPackets === 'number') {\n    keyInsightsParts.push(\n      `${totalPackets.toLocaleString()} packet${totalPackets === 1 ? '' : 's'} have been seen so far.`\n    )\n  }\n\n  const keyInsights = keyInsightsParts.join(' ')\n\n  return [\n    `Summary: ${summary}`,\n    '',\n    `Key insights: ${keyInsights}`,\n    '',\n    'Overall risk: Low',\n    '',\n    'Recommended actions: If you see high-traffic apps that you do not recognise or do not need, consider closing them or limiting their background access. Avoid sharing sensitive information on untrusted networks.'\n  ].join('\\n')\n}\n\nfunction buildGeminiPrompt(snapshot: PrivacySnapshot | null | undefined): string {\n  const safeSnapshot = snapshot ?? ({} as Partial<PrivacySnapshot>)\n  const {\n    totalApps,\n    totalPackets,\n    totalBytes,\n    topApps,\n    focusAppName,\n    focusAppBytes,\n    focusApp,\n    geoSummary,\n    geoByCountry\n  } = safeSnapshot\n\n  const effectiveFocusName = focusAppName ?? focusApp?.name\n  const effectiveFocusBytes =\n    typeof focusAppBytes === 'number'\n      ? focusAppBytes\n      : typeof focusApp?.totalBytes === 'number'\n        ? focusApp.totalBytes\n        : undefined\n\n  const safeTopApps = Array.isArray(topApps) ? topApps.slice(0, 5) : []\n\n  const topAppsText =\n    safeTopApps.length > 0\n      ? safeTopApps\n          .map((app: TopApp, idx: number) => {\n            const name = app.name ?? 'Unknown'\n            const bytes = typeof app.totalBytes === 'number' ? app.totalBytes : undefined\n            return `${idx + 1}. ${name}${bytes !== undefined ? ` (${bytes} bytes)` : ''}`\n          })\n          .join('\\n')\n      : 'No top apps available.'\n\n  let destinationsText = 'No destination information available.'\n  if (typeof geoSummary === 'string' && geoSummary.trim().length > 0) {\n    destinationsText = geoSummary.trim()\n  } else if (geoByCountry && typeof geoByCountry === 'object') {\n    const entries = Object.entries(geoByCountry).filter(\n      ([, value]) => typeof value === 'number' && value > 0\n    )\n    if (entries.length > 0) {\n      // Sort by value descending (e.g. flows) and take top 3\n      const topCountries = entries\n        .sort((a, b) => (b[1] as number) - (a[1] as number))\n        .slice(0, 3)\n        .map(([country, value]) => `${country} (${(value as number).toLocaleString()} flows)`)\n      destinationsText = `Most traffic appears to be going to: ${topCountries.join(', ')}.`\n    }\n  }\n\n  const baseContext = `Session stats:\n- Total apps observed: ${totalApps ?? 'unknown'}\n- Total packets: ${totalPackets ?? 'unknown'}\n- Total bytes: ${totalBytes ?? 'unknown'}\n\nTop apps:\n${topAppsText}\n\nData destinations:\n${destinationsText}\n`\n\n  if (effectiveFocusName) {\n    return `\nYou are PrivacyAI, a concise desktop network privacy assistant.\n\nYou are analysing ONE specific application on a user's machine.\n\nApplication of interest:\n- Name: ${String(effectiveFocusName)}\n- Observed bytes: ${typeof effectiveFocusBytes === 'number' ? effectiveFocusBytes : 'unknown'}\n\nOverall capture context:\n${baseContext}\n\nRules:\n1) Focus your explanation on the selected application above. You may briefly compare it to other apps only for context.\n2) Always answer using EXACTLY these four sections, in this order:\n\nSummary: <2–3 sentences describing what this app seems to be doing and how \"normal\" the traffic looks. If destination / geolocation information is available, explicitly mention where most of the data appears to be going (e.g., mostly domestic vs some traffic to other countries).>\nKey insights: <2–4 of the most important observations about this app's behaviour. Do NOT include recommendations here.>\nOverall risk: <Low, Medium, or High only. Do not add any explanation or extra words.>\nRecommended actions: <Short, practical steps the user could take regarding this one app. Avoid boilerplate like \"no actions required\"; if you genuinely have no meaningful suggestions, keep this section very short.>\n\n3) Use plain text. Do NOT use markdown, bullets, asterisks, emojis, or headings.\n4) Be factual and grounded in the numbers you see. If something is unknown, say that clearly.\n5) Total length should be under 250 words.\n\nNow respond for this selected application only.\n`\n  }\n\n  return `\nYou are PrivacyAI, a concise desktop network privacy assistant.\n\nYou are analysing the OVERALL network activity on a user's machine.\n\nOverall capture context:\n${baseContext}\n\nRules:\n1) Describe overall behaviour across apps, not just one.\n2) Always answer using EXACTLY these four sections, in this order:\n\nSummary: <2–3 sentences summarising what the current capture looks like overall. If destination / geolocation information is available, explicitly mention where most of the data appears to be going (e.g., mostly local vs significant traffic to specific regions or countries).>\nKey insights: <2–4 of the most important observations about this capture. Do NOT include recommendations here.>\nOverall risk: <Low, Medium, or High only. Do not add any explanation or extra words.>\nRecommended actions: <Short, practical steps the user could take to improve privacy or reduce unnecessary traffic. Avoid boilerplate like \"no actions required\"; if you genuinely have no meaningful suggestions, keep this section very short.>\n\n3) Use plain text. Do NOT use markdown, bullets, asterisks, emojis, or headings.\n4) Be factual and grounded in the numbers you see. If something is unknown, say that clearly.\n5) Total length should be under 200 words.\n\nNow respond for the overall session.\n`\n}\n\n// This is the ONLY place that talks to the LLM.\n\nexport async function getPrivacySummary(snapshot: PrivacySnapshot): Promise<string> {\n  // Guard against bad/empty input so we never crash on undefined\n  if (!snapshot) {\n    console.warn('[PrivacyAI] No snapshot passed to getPrivacySummary, using empty summary')\n    return buildLocalSummary({\n      totalApps: 0,\n      totalPackets: 0,\n      topApps: []\n    })\n  }\n\n  const apiKey = process.env.GOOGLE_API_KEY\n\n  if (!apiKey) {\n    console.log('[PrivacyAI] No GOOGLE_API_KEY found, using local summary')\n    return buildLocalSummary(snapshot)\n  }\n\n  console.log('[PrivacyAI] GOOGLE_API_KEY present, calling Gemini...')\n\n  const genAI = new GoogleGenerativeAI(apiKey)\n  const enrichedSnapshot: PrivacySnapshot = { ...snapshot }\n\n  const geo = enrichedSnapshot.geo\n\n  if (geo && typeof geo === 'object') {\n    const topCountries = Array.isArray(geo.topCountries) ? geo.topCountries : []\n\n    if (topCountries.length > 0) {\n      const parts = topCountries\n        .filter(\n          (entry): entry is { country: string; count: number } =>\n            !!entry && typeof entry.country === 'string'\n        )\n        .map((entry) => {\n          const country = entry.country\n          const count = typeof entry.count === 'number' ? entry.count : undefined\n          return count !== undefined ? `${country} (${count} flows)` : country\n        })\n\n      const totalFlows = typeof geo.totalFlows === 'number' ? geo.totalFlows : undefined\n\n      enrichedSnapshot.geoSummary = `Most geo-identified flows appear to be going to: ${parts.join(\n        ', '\n      )}${\n        totalFlows !== undefined\n          ? `. Total geo-identified flows: ${totalFlows.toLocaleString()}.`\n          : '.'\n      }`\n\n      const byCountry: Record<string, number> = {}\n      for (const entry of topCountries) {\n        if (!entry || typeof entry.country !== 'string') continue\n        const key = entry.country\n        const count = typeof entry.count === 'number' ? entry.count : 0\n        byCountry[key] = (byCountry[key] ?? 0) + count\n      }\n      if (Object.keys(byCountry).length > 0) {\n        enrichedSnapshot.geoByCountry = byCountry\n      }\n    }\n  }\n\n  const prompt = buildGeminiPrompt(enrichedSnapshot)\n\n  try {\n    const model = genAI.getGenerativeModel({\n      model: 'gemini-2.5-pro',\n      generationConfig: {\n        temperature: 0.3\n      }\n    })\n\n    const result = await model.generateContent(prompt)\n    const text =\n      result.response?.text?.() ?? result.response?.candidates?.[0]?.content?.parts?.[0]?.text\n\n    console.log('[PrivacyAI] Gemini raw response:', JSON.stringify(result, null, 2))\n\n    if (!text || typeof text !== 'string' || text.trim().length === 0) {\n      console.warn('[PrivacyAI] Gemini returned no usable text, falling back to local summary')\n      return buildLocalSummary(snapshot)\n    }\n\n    return text.trim()\n  } catch (err) {\n    console.error('[PrivacyAI] Gemini call failed, falling back:', err)\n    return buildLocalSummary(snapshot)\n  }\n}\n"
    }
  ]
}
