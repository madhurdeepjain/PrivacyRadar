{
  "sourceFile": "renderer/src/components/NetworkMonitor.tsx",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1765304459969,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1765304459969,
      "name": "Commit-0",
      "content": "import { motion, AnimatePresence } from 'framer-motion'\nimport AdvancedNetworkMonitor from './AdvancedNetworkMonitor'\nimport BasicNetworkMonitor from './BasicNetworkMonitor'\nimport { useState, useEffect, useRef } from 'react'\nimport { PacketMetadata, AppStats, InterfaceOption, ProcessRegistry } from '../types'\n\nfunction NetworkMonitor({\n  colorAccessibility,\n  handleAdvancedModeChange,\n  maxPackets,\n  advancedMode,\n  darkMode\n}: {\n  handleAdvancedModeChange: () => void\n  colorAccessibility: boolean\n  maxPackets: number\n  advancedMode: boolean\n  darkMode: boolean\n}): React.JSX.Element {\n  // State\n  const [packets, setPackets] = useState<PacketMetadata[]>([])\n  const [packetCount, setPacketCount] = useState(0)\n  const [totalBytes, setTotalBytes] = useState(0)\n  const [appStatsMap, setAppStatsMap] = useState<Record<string, AppStats>>({})\n  const [bytesPerSecond, setBytesPerSecond] = useState(0)\n  const throughputSamplesRef = useRef<Array<{ timestamp: number; size: number }>>([])\n  const [isCapturing, setIsCapturing] = useState(false)\n  const [isUpdatingCapture, setIsUpdatingCapture] = useState(false)\n  const [interfaces, setInterfaces] = useState<InterfaceOption[]>([])\n  const [selectedInterfaces, setSelectedInterfaces] = useState<string[]>([])\n  const [registries, setRegistries] = useState<Array<Map<string, ProcessRegistry>>>(\n    new Array<Map<string, ProcessRegistry>>(new Map())\n  )\n  const [location, setLocation] = useState(null)\n\n  useEffect(() => {\n    window.api.onProcessRegistryData((data: Map<string, ProcessRegistry>) => {\n      if (!location) {\n        window.api.getPublicIP().then((publicIp) => {\n          window.api.getGeoLocation(publicIp).then((loc) => {\n            setLocation(loc)\n          })\n        })\n      }\n      if (data) {\n        setRegistries([...registries, data])\n      }\n    })\n  }, [location, registries])\n\n  // API: Initialize Interfaces\n  useEffect(() => {\n    const init = async (): Promise<void> => {\n      try {\n        const result = await window.api.getNetworkInterfaces()\n        setInterfaces(result.interfaces)\n        setIsCapturing(result.isCapturing)\n      } catch (err) {\n        console.error('Failed to load interfaces', err)\n      }\n    }\n    init()\n  }, [])\n\n  // Actions\n  const handleToggleCapture = async (): Promise<void> => {\n    setIsUpdatingCapture(true)\n    try {\n      const result = isCapturing ? await window.api.stopCapture() : await window.api.startCapture()\n      setIsCapturing(result.isCapturing)\n      if (!result.isCapturing) {\n        setBytesPerSecond(0)\n        throughputSamplesRef.current = []\n      }\n    } catch (err) {\n      console.error('Capture toggle failed', err)\n    } finally {\n      setIsUpdatingCapture(false)\n    }\n  }\n\n  // API: Initialize Interfaces\n  useEffect(() => {\n    const init = async (): Promise<void> => {\n      try {\n        const result = await window.api.getNetworkInterfaces()\n        setInterfaces(result.interfaces)\n        setSelectedInterfaces(\n          result.selectedInterfaceNames.length > 0\n            ? result.selectedInterfaceNames\n            : result.interfaces.map((i) => i.name)\n        )\n        setIsCapturing(result.isCapturing)\n      } catch (err) {\n        console.error('Failed to load interfaces', err)\n      }\n    }\n    init()\n  }, [])\n\n  // API: Network Data Listener\n  useEffect(() => {\n    const handleData = (data: PacketMetadata): void => {\n      // Packets\n      setPacketCount((p) => p + 1)\n      setPackets((prev) => [data, ...prev].slice(0, maxPackets))\n      setTotalBytes((p) => p + data.size)\n\n      // App Stats\n      setAppStatsMap((prev) => {\n        const appName = data.appName || 'UNKNOWN'\n        const key = appName\n        const existing = prev[key]\n\n        if (existing) {\n          return {\n            ...prev,\n            [key]: {\n              ...existing,\n              packetCount: existing.packetCount + 1,\n              totalBytes: existing.totalBytes + data.size,\n              lastSeen: Math.max(existing.lastSeen, data.timestamp)\n            }\n          }\n        }\n        return {\n          ...prev,\n          [key]: {\n            name: appName,\n            pid: data.pid,\n            packetCount: 1,\n            totalBytes: data.size,\n            lastSeen: data.timestamp\n          }\n        }\n      })\n\n      // Throughput\n      const now = data.timestamp\n      const samples = throughputSamplesRef.current\n      samples.push({ timestamp: now, size: data.size })\n\n      // Cleanup old samples (30s window)\n      const windowStart = now - 30000\n      while (samples.length > 0 && samples[0].timestamp < windowStart) {\n        samples.shift()\n      }\n\n      // Calculate rate\n      if (samples.length > 0) {\n        const recentBytes = samples.reduce((acc, s) => acc + s.size, 0)\n        const span = Math.max(1, (now - samples[0].timestamp) / 1000)\n        setBytesPerSecond(recentBytes / span)\n      } else {\n        setBytesPerSecond(0)\n      }\n    }\n\n    window.api.onNetworkData(handleData)\n    return () => {\n      window.api.removeNetworkDataListener()\n    }\n  }, [maxPackets])\n\n  // Throughput Decay Interval\n  useEffect(() => {\n    const interval = setInterval(() => {\n      const samples = throughputSamplesRef.current\n      if (samples.length === 0) {\n        setBytesPerSecond((b) => (b > 0 ? 0 : b))\n        return\n      }\n      const now = Date.now()\n      const windowStart = now - 30000\n      while (samples.length > 0 && samples[0].timestamp < windowStart) {\n        samples.shift()\n      }\n      if (samples.length === 0) {\n        setBytesPerSecond(0)\n      } else {\n        const recentBytes = samples.reduce((acc, s) => acc + s.size, 0)\n        const span = Math.max(1, (now - samples[0].timestamp) / 1000)\n        setBytesPerSecond(recentBytes / span)\n      }\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <main className=\"flex-1 flex flex-col overflow-hidden relative bg-muted/10\">\n      <AnimatePresence mode=\"wait\">\n        <motion.div\n          key={advancedMode.toString()}\n          initial={{ opacity: 0, x: 20 }}\n          animate={{ opacity: 1, x: 0 }}\n          exit={{ opacity: 0, x: -20 }}\n          transition={{ duration: 0.2 }}\n          className=\"h-full flex flex-col overflow-hidden\"\n        >\n          {advancedMode ? (\n            <AdvancedNetworkMonitor\n              handleAdvancedModeChange={handleAdvancedModeChange}\n              packets={packets}\n              packetCount={packetCount}\n              totalBytes={totalBytes}\n              bytesPerSecond={bytesPerSecond}\n              selectedInterfaces={selectedInterfaces}\n              darkMode={darkMode}\n              isCapturing={isCapturing}\n              handleToggleCapture={handleToggleCapture}\n              isUpdatingCapture={isUpdatingCapture}\n              setSelectedInterfaces={setSelectedInterfaces}\n              setInterfaces={setInterfaces}\n              setIsCapturing={setIsCapturing}\n              appStatsMap={appStatsMap}\n              setAppStatsMap={setAppStatsMap}\n              interfaces={interfaces}\n            />\n          ) : (\n            <BasicNetworkMonitor\n              colorAccessibility={colorAccessibility}\n              handleAdvancedModeChange={handleAdvancedModeChange}\n              packets={packets}\n              location={location}\n              registries={registries}\n              handleToggleCapture={handleToggleCapture}\n              isUpdatingCapture={isUpdatingCapture}\n              isCapturing={isCapturing}\n              interfaces={interfaces}\n            />\n          )}\n        </motion.div>\n      </AnimatePresence>\n    </main>\n  )\n}\n\nexport default NetworkMonitor\n"
    }
  ]
}
